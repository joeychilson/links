// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: comments.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const comment = `-- name: Comment :one
SELECT 
    c.id,
    c.link_id,
    c.parent_id,
    c.content,
    c.created_at,
    c.updated_at,
    u.username,
    (SELECT COUNT(*) FROM comments WHERE parent_id = c.id) AS replies,
    (SELECT COALESCE(SUM(vote), 0) FROM comment_votes WHERE comment_id = c.id) AS score,
    COALESCE(cv.vote, 0) AS user_vote
FROM 
    comments c
JOIN 
    users u ON c.user_id = u.id
LEFT JOIN 
    comment_votes cv ON c.id = cv.comment_id AND cv.user_id = $2
WHERE 
    c.id = $1
`

type CommentParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type CommentRow struct {
	ID        uuid.UUID
	LinkID    uuid.UUID
	ParentID  pgtype.UUID
	Content   string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Username  string
	Replies   int64
	Score     interface{}
	UserVote  int16
}

func (q *Queries) Comment(ctx context.Context, arg CommentParams) (CommentRow, error) {
	row := q.db.QueryRow(ctx, comment, arg.ID, arg.UserID)
	var i CommentRow
	err := row.Scan(
		&i.ID,
		&i.LinkID,
		&i.ParentID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Replies,
		&i.Score,
		&i.UserVote,
	)
	return i, err
}

const commentFeed = `-- name: CommentFeed :many
WITH RECURSIVE comment_tree AS (
    SELECT 
        c.id,
        c.link_id,
        c.parent_id,
        c.content,
        c.created_at,
        c.updated_at,
        u.username,
        (SELECT COUNT(*) FROM comments WHERE parent_id = c.id) AS replies,
        (SELECT COALESCE(SUM(vote), 0) FROM comment_votes WHERE comment_id = c.id) AS score,
        COALESCE(cv.vote, 0) AS user_vote
    FROM 
        comments c
    JOIN 
        users u ON c.user_id = u.id
    LEFT JOIN 
        comment_votes cv ON c.id = cv.comment_id AND cv.user_id = $2
    WHERE 
        c.link_id = $1 AND c.parent_id IS NULL

    UNION ALL

    SELECT 
        c.id,
        c.link_id,
        c.parent_id,
        c.content,
        c.created_at,
        c.updated_at,
        u.username,
        (SELECT COUNT(*) FROM comments WHERE parent_id = c.id) AS replies,
        (SELECT COALESCE(SUM(vote), 0) FROM comment_votes WHERE comment_id = c.id) AS score,
        COALESCE(cv.vote, 0) AS user_vote
    FROM 
        comments c
    JOIN 
        comment_tree ct ON c.parent_id = ct.id
    JOIN 
        users u ON c.user_id = u.id
    LEFT JOIN 
        comment_votes cv ON c.id = cv.comment_id AND cv.user_id = $2
)
SELECT id, link_id, parent_id, content, created_at, updated_at, username, replies, score, user_vote FROM comment_tree
ORDER BY score DESC, created_at
LIMIT $3 OFFSET $4
`

type CommentFeedParams struct {
	LinkID uuid.UUID
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type CommentFeedRow struct {
	ID        uuid.UUID
	LinkID    uuid.UUID
	ParentID  pgtype.UUID
	Content   string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Username  string
	Replies   int64
	Score     interface{}
	UserVote  int16
}

func (q *Queries) CommentFeed(ctx context.Context, arg CommentFeedParams) ([]CommentFeedRow, error) {
	rows, err := q.db.Query(ctx, commentFeed,
		arg.LinkID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommentFeedRow
	for rows.Next() {
		var i CommentFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.LinkID,
			&i.ParentID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Replies,
			&i.Score,
			&i.UserVote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (user_id, link_id, content) VALUES ($1, $2, $3) RETURNING id
`

type CreateCommentParams struct {
	UserID  uuid.UUID
	LinkID  uuid.UUID
	Content string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createComment, arg.UserID, arg.LinkID, arg.Content)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createReply = `-- name: CreateReply :one
INSERT INTO comments (user_id, link_id, parent_id, content) VALUES ($1, $2, $3, $4) RETURNING id
`

type CreateReplyParams struct {
	UserID   uuid.UUID
	LinkID   uuid.UUID
	ParentID pgtype.UUID
	Content  string
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createReply,
		arg.UserID,
		arg.LinkID,
		arg.ParentID,
		arg.Content,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
